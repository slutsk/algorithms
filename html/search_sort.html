<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Поиск и сортировки</title>
    <link rel="stylesheet" href="../css/main.css">
    <script type="text/javascript" async
           src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body>
    <div class = "main">
        <h2>ПОИСК И СОРТИРОВКИ</h2>
        <p>
        В программировании <i><b>поиск</b></i> является одной из наиболее часто выполняемых операций. 
        Пусть есть некоторое множество из \(n\) элементов, которое задано в виде массива 
        \(a[0 .. n–1]\).
        </p>
        <p>
        Среди простейших типов задач на поиск, можно выделить:
        <ol>    
             <li>Найти хотя бы один элемент, равный заданному элементу \(x\). В результате необходимо получить \(i\) – индекс элемента массива, такой, что \(a[i] = x\).</li>
            <li>Найти все элементы, равные заданному \(x\). Результатом служит количество таких элементов и (или) их индексы.</li> 
        </ol>
        </p>
            Иногда поиск организуется не по совпадению с элементом x, а по выполнению некоторых условий. Примером может служить поиск элементов, удовлетворяющих условиям x_1≤a[i]≤x_2, где x_1и x_2 заданы. 
        При этом, как правило, приходится последовательно просматривать весь массив. Такой метод называется линейным или последовательным поиском. Временная сложность линейного поиска O(n).
        Рассмотрим сначала реализацию последовательного поиска для задач типа 1. Поиск заканчивается при выполнении одного из двух следующих условий:
            Элемент найден, т.е. в массиве есть такой элемент a[i], что a[i] = x.
            Весь массив просмотрен и совпадения не обнаружено.
        Одним из возможных решений данной задачи может быть следующее: пусть flag – переменная логического типа, которая имеет значение true, если элемент в массиве найден, и false – в противном случае.
         bool flag = false;
         for(int i = 0; i < n; i++)
             if(a[i] == x)
                 flag = true;
        Если после выполнения алгоритма flag = true, то элемент найден, если переменная не изменила своего значения, то элемента нет.
        Часто требуется не только определить, есть ли в массиве искомый элемент, но и установить, на каком месте он находится. Будем хранить индекс найденного элемента в переменной ind:  
        int ind = -1;
        for(int i = 0; i < n; i++)
            if(a[i] == x)
                ind = i;
        После выполнения данного алгоритма по значению переменной ind можно определить, есть ли в массиве искомый искомый элемент, и если есть, то где он стоит. Если в массиве несколько таких элементов, то в переменной ind будет хранится номер последнего из них. Если такого элемента нет, то значение переменной  ind не изменится (останется равным –1).
        Можно сократить время поиска элемента. Будем останавливаться сразу, после того, как элемент найден. Тогда, весь массив придется просмотреть лишь в том случае, когда иcкомый элемент последний или его нет вообще.
        int ind = 0;
        while(ind < n && a[ind] != x)
           ind++;
        При такой реализации цикл закончит работу, либо когда найдется искомый элемент, либо когда ind = n (то есть элемент не найден).
        Заметим, что в цикле используются два сравнения, что немного замедляет работу программы. 
        Добавим в конец массива элемент равный элементу x. В этом случае, гарантируется, что совпадение с элементом x произойдет (то есть искомый элемент будет найден), а значит можно отбросить условие ind < n. Такой вспомагательный элемент называют «барьером» или «часовым», так как он препятствет выходу за пределы массива. В массиве теперь будет n+1 элементов.
        a[n] = x;
        int ind = 0;
        while(a[ind] != x)
           ind++;
        Если, после завершения цикла, ind = n, то искомого элемента в массиве нет.
        При реализации задач типа 2 (нахождение количества элементов) в любом случае придется просматривать весь массив.
        Если в задаче нужно найти количество элементов, то заведем переменную, значение которой будем увеличивать на 1 каждый раз, когда искомый элемент найден. Такую переменную называют «счетчиком». Перед поиском элементов  массива «счетчику» присваивается начальное значение (в данном случае равное нулю). 
        
    </div>
</body>
</html>