<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Поиск и сортировки</title>
    <link rel="stylesheet" href="../css/main.css">
    <script type="text/javascript" async
           src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body>
    <div class = "main">
        <h2>ПОИСК И СОРТИРОВКИ</h2>
        <p>
        В программировании <i><b>поиск</b></i> является одной из наиболее часто выполняемых операций. 
        Пусть есть некоторое множество из \(n\) элементов, которое задано в виде массива 
        \(a[0 .. n–1]\).
        </p>
        <p>
        Среди простейших типов задач на поиск, можно выделить:
        <ol>    
             <li>Найти хотя бы один элемент, равный заданному элементу \(x\). В результате необходимо получить \(i\) – индекс элемента массива, такой, что \(a[i] = x\).</li>
            <li>Найти все элементы, равные заданному \(x\). Результатом служит количество таких элементов и (или) их индексы.</li> 
        </ol>
        </p>
        <p>Иногда поиск организуется не по совпадению с элементом \(x\), а по выполнению некоторых условий. Примером может служить поиск элементов, удовлетворяющих условиям \(x_1≤a[i]≤x_2\), где \(x_1\) и \(x_2\) заданы. 
           При этом, как правило, приходится последовательно просматривать весь массив. Такой метод называется линейным или последовательным поиском. Временная сложность линейного поиска \(O(n)\).
        </p>
        <p> Рассмотрим реализацию последовательного поиска для задач первого типа. Поиск заканчивается при выполнении одного из двух следующих условий:
            Элемент найден, т.е. в массиве есть такой элемент \(a[i]\), что \(a[i] = x\).
            Весь массив просмотрен и совпадения не обнаружено.
        </p>
        <p>    
        Одним из возможных решений данной задачи может быть следующее: пусть flag – переменная логического типа, которая имеет значение true, если элемент в массиве найден, и false – в противном случае.
        </p>
        <pre class = "code"><code>bool flag = false;
for(int i = 0; i < n; i++)
    if(a[i] == x)
        flag = true;</code></pre>         
        <p>   
        Если после выполнения алгоритма \(flag == true\), то элемент найден, если переменная не изменила своего значения, то элемента нет.
        </p>
        <p>
        Часто требуется не только определить, есть ли в массиве искомый элемент, но и установить, на каком месте он находится. Будем хранить индекс найденного элемента в переменной \(ind\):  
        </p>
        <pre class="code"><code>int ind = -1;
for(int i = 0; i < n; i++)
    if(a[i] == x)
        ind = i;</code></pre>
        <p>
        После выполнения данного алгоритма по значению переменной \(ind\) можно определить, есть ли в массиве искомый искомый элемент, и если есть, то где он стоит. Если в массиве несколько таких элементов, то в переменной \(ind\) будет хранится номер последнего из них. Если такого элемента нет, то значение переменной  \(ind\) не изменится (останется равным –1).
        </p>
        <p>
        Можно сократить время поиска элемента. Будем останавливаться сразу, после того, как элемент найден. Тогда, весь массив придется просмотреть лишь в том случае, когда иcкомый элемент последний или его нет вообще.
        </p>
        <pre class="code"><code>int ind = 0;
while(ind < n && a[ind] != x)
    ind++;</code></pre>
       <p>
        При такой реализации цикл закончит работу, либо когда найдется искомый элемент, либо когда \(ind == n\) (то есть элемент не найден).
        </p>
        <p>
        Заметим, что в цикле используются два сравнения, что немного замедляет работу программы. 
        Добавим в конец массива элемент равный элементу \(x\). В этом случае, гарантируется, что совпадение с элементом \(x\) произойдет (то есть искомый элемент будет найден), а значит можно отбросить условие \(ind < n\). Такой вспомагательный элемент называют <i><b>«барьером»</b></i> или <i><b>«часовым»</b></i>, так как он препятствет выходу за пределы массива. В массиве теперь будет \(n+1\) элементов.
        </p>

<pre class="code"><code>a[n] = x;
int ind = 0;
while(a[ind] != x)
    ind++;</code></pre>
        <p>   
           Если, после завершения цикла, \(ind == n\), то искомого элемента в массиве нет.
        </p>
        <p>
        При реализации задач типа 2 (нахождение количества элементов) в любом случае придется просматривать весь массив.
        Если в задаче нужно найти количество элементов, то заведем переменную, значение которой будем увеличивать на 1 каждый раз, когда искомый элемент найден. Такую переменную называют<i><b> «счетчиком»</b></i>. 
        Перед поиском элементов  массива <i><b>«счетчику»</b></i> присваивается начальное значение (в данном случае равное нулю). 
        </p>

<pre class="code"><code>int cnt = 0;
for(int i = 0; i < n; i++){
   if(a[i]==x)
        cnt++;
}</code></pre> 
<hr>     
<h2>ПОИСК МАКСИМАЛЬНОГО И МИНИМАЛЬНОГО ЭЛЕМЕНТОВ В МАССИВЕ</h2>
<p>
    Рассмотрим задачу нахождения максимального элемента.
    В начале алгоритма примем элемент \(a[0]\) за максимальный и сохраним его в переменной \(mx\), а затем последовательно будем
    сравнивать это значение со значениями \(a[i]\).
    Если, в процессе сравнения, найдется элемент \(a[i]\), который большее,
    чем значение \(mx\), то присваиваем новое найденное значение \(a[i]\) переменной \(mx\), а затем продолжаем сравнения.

</p>
<pre class = "code"><code>int mx = a[0];
for(int i = 1; i < n; i++)
{
    if(a[i] > mx)
        mx = a[i];
}</code></pre>
<p>
    Можно переписать данный код используюя функциию \(max()\).
</p>
<pre class = "code"><code>int mx = a[0];
for(int i = 1; i < n; i++)
        mx = max(mx, a[i]);</code></pre>

<p>
  Часто бывает нужно найти не только максимальный элемент, 
  но и его положение в массиве (индекс).
  Для этого заведем еще одну переменную \(ind\).
</p>
<pre class = "code"><code>int mx = a[0];
int ind = 0;
for(int i = 1; i < n; i++)
{
    if(a[i] > mx)
    {
        mx = a[i];
        ind = i;
    }
}</code></pre>
<p>
ИЛИ (если нужен только индекс)
</p>
<pre class = "code"><code>int ind = 0;
for(int i = 1; i < n; i++)
    if(a[i] > a[ind])
        ind = i;</code></pre>
        <p>
          Заметим, что если в массиве есть несколько максимальных элементов, 
          то в переменной \(ind\) сохраняется первый найденный индекс.
          Если использовать условие \(a[i]>=a[ind]\), то будет сохранен 
          последний индекс максимального значения.<br>
          Если нужно найти минимальный элемент в массиве или его индекс,
          то нужно лишь в условии \(if\) поменять знак \(«>»\) на \(«<»\).<br>
          Понятно, что такой поиск максимального (минимального) элемента происходит 
          за \(O(n)\). 
        </p>
        <h2>СОРТИРОВКИ</h2>
        <p>
        <i><b>Сортировкой</b></i> (англ. sorting) называется процесс упорядочивания множества объектов по какому-либо признаку.
        Объектами сортировки могут быть числа, строки, точки в пространстве заданные своими координатами.
        </p>
        <p>
        Очень важно, что при сортировке объекты должны быть сравнимы по какому-то правилу (используя знаки «<» «>» «==»).
        </p>
        <p>
        Пусть есть \(n\) сравниваемых элементов, т.е. элементов которые можно сравнивать: \(a_1, a_2, …, a_n\) (для простоты будем считать, что это числа).
        Наша задача данные элементы отсортировать, то есть выстроить их в определенном порядке, например:
        \(a'_1 \leq a'_2 \leq ... \leq a'_n\).
        </p>
        <p>
            Если после сортировки элементов \(a_1, a_2, … , a_n\) получается последовательность элементов \(a'_1, a'_2, …, a'_n\) такая, что
            \(a'_1 \leq a'_2 \leq …, \leq a'_n\), то говорят, что элементы отсортированны <i><b>по неубыванию</b></i>. <br>
            Например, для чисел 7, 10, 1, 2, 1, 3, 7 при сортировке по неубыванию получим: 1, 1, 2, 3, 7, 7, 10.  
        </p>

        <p>
            Если после сортировки элементов \(a_1, a_2, … , a_n\) получается последовательность элементов \(a'_1, a'_2, …, a'_n\) такая, что
            \(a'_1 \geq a'_2 \geq …, \geq a'_n\), то говорят, что элементы отсортированны <i><b>по невозрастанию</b></i>. <br>
            Например, для чисел 7, 10, 1, 2, 1, 3, 7 при сортировке по неубыванию получим: 10, 7, 7, 3, 2, 1, 1.  
        </p>

        <p>
            Если после сортировки элементов \(a_1, a_2, … , a_n\) получается последовательность элементов \(a'_1, a'_2, …, a'_n\) такая, что
            \(a'_1 < a'_2 < …, < a'_n\), то говорят, что элементы отсортированны <i><b>по возрастанию</b></i>. <br>
            Например, для чисел 7, 10, 1, 2, 5, 3, 8 при сортировке по возрастанию получим: 1, 2, 3, 5, 7, 8, 10.  
        </p>

        <p>
            Если после сортировки элементов \(a_1, a_2, … , a_n\) получается последовательность элементов \(a'_1, a'_2, …, a'_n\) такая, что
            \(a'_1 > a'_2 > …, > a'_n\), то говорят, что элементы отсортированны <i><b>по убыванию</b></i>. <br>
            Например, для чисел 7, 10, 1, 2, 5, 3, 8 при сортировке по убыванию получим: 10, 8, 7, 5, 3, 2, 1.  
        </p>

    <h2>Сортировка выбором (Selection Sort)</h2>
<pre class = "code"><code>void selection_sort(int a[], int n)
{
    for(int i = 0; i < n-1; i++)
        for(int j = i+1; j < n; j++)
            if(a[i] > a[j])
                swap(a[i], a[j]);
}</code></pre>
        <p>
            Рассмотрим еще один вариант <i><b>сортировки выбором</b></i>.
        </p>
<pre class = "code"><code>void selection_sort(int a[], int n)
{
    for(int i = 0; i < n-1; i++){
        int key = i;
        for(int j = i+1; j < n; j++)
            if(a[j] < a[key])
                key = j;
        swap(a[i], a[key]);
    }
}</code></pre>
       
       <h2>сортировка вставками (insertion sort)</h2>
<pre class="code"><code>void  insertion_sort(int a[], int n){
for(int i = 1; i < n; i++){
    int key = a[i];
        int j = i-1;
        while(j >-1 && key < a[j] ){
            a[j+1] = a[j];
            j--;
        }
        a[j+1] = key;
    }
}</code></pre>
     <h2>пузырьковая сортировка (bubble sort)</h2>
     <blockquote>
        <p>"The bubble sort has nothing to recommend it, except a catchy name and the fact that it's easy to code. It's a really awful algorithm and should be avoided."</p>
        <cite>Donald Knuth</cite>
      </blockquote>
<pre class="code"><code>void bubble_sort(int a[], int n){
for(int i = 0; i < n - 1; i++)
    for(int j = 0; j < n - 1 ; j++)
        if(a[j] > a[j+1])
            swap(a[j], a[j+1]);
}</code></pre>
    </div>
</body>
</html>