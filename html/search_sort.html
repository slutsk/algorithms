<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Поиск и сортировки</title>
    <link rel="stylesheet" href="../css/main.css">
    <script type="text/javascript" async
           src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body>
    <div class = "main">
        <h2>ПОИСК И СОРТИРОВКИ</h2>
        <p>
        В программировании <i><b>поиск</b></i> является одной из наиболее часто выполняемых операций. 
        Пусть есть некоторое множество из \(n\) элементов, которое задано в виде массива 
        \(a[0 .. n–1]\).
        </p>
        <p>
        Среди простейших типов задач на поиск, можно выделить:
        <ol>    
             <li>Найти хотя бы один элемент, равный заданному элементу \(x\). В результате необходимо получить \(i\) – индекс элемента массива, такой, что \(a[i] = x\).</li>
            <li>Найти все элементы, равные заданному \(x\). Результатом служит количество таких элементов и (или) их индексы.</li> 
        </ol>
        </p>
        <p>Иногда поиск организуется не по совпадению с элементом \(x\), а по выполнению некоторых условий. Примером может служить поиск элементов, удовлетворяющих условиям \(x_1≤a[i]≤x_2\), где \(x_1\) и \(x_2\) заданы. 
           При этом, как правило, приходится последовательно просматривать весь массив. Такой метод называется линейным или последовательным поиском. Временная сложность линейного поиска \(O(n)\).
        </p>
        <p> Рассмотрим реализацию последовательного поиска для задач первого типа. Поиск заканчивается при выполнении одного из двух следующих условий:
            Элемент найден, т.е. в массиве есть такой элемент \(a[i]\), что \(a[i] = x\).
            Весь массив просмотрен и совпадения не обнаружено.
        </p>
        <p>    
        Одним из возможных решений данной задачи может быть следующее: пусть flag – переменная логического типа, которая имеет значение true, если элемент в массиве найден, и false – в противном случае.
        </p>
        <pre class = "code"><code>bool flag = false;
for(int i = 0; i < n; i++)
    if(a[i] == x)
        flag = true;</code></pre>         
        <p>   
        Если после выполнения алгоритма \(flag == true\), то элемент найден, если переменная не изменила своего значения, то элемента нет.
        </p>
        <p>
        Часто требуется не только определить, есть ли в массиве искомый элемент, но и установить, на каком месте он находится. Будем хранить индекс найденного элемента в переменной \(ind\):  
        </p>
        <pre class="code"><code>int ind = -1;
for(int i = 0; i < n; i++)
    if(a[i] == x)
        ind = i;</code></pre>
        <p>
        После выполнения данного алгоритма по значению переменной \(ind\) можно определить, есть ли в массиве искомый искомый элемент, и если есть, то где он стоит. Если в массиве несколько таких элементов, то в переменной \(ind\) будет хранится номер последнего из них. Если такого элемента нет, то значение переменной  \(ind\) не изменится (останется равным –1).
        </p>
        <p>
        Можно сократить время поиска элемента. Будем останавливаться сразу, после того, как элемент найден. Тогда, весь массив придется просмотреть лишь в том случае, когда иcкомый элемент последний или его нет вообще.
        </p>
        <pre class="code"><code>int ind = 0;
while(ind < n && a[ind] != x)
    ind++;</code></pre>
       <p>
        При такой реализации цикл закончит работу, либо когда найдется искомый элемент, либо когда \(ind == n\) (то есть элемент не найден).
        </p>
        <p>
        Заметим, что в цикле используются два сравнения, что немного замедляет работу программы. 
        Добавим в конец массива элемент равный элементу \(x\). В этом случае, гарантируется, что совпадение с элементом \(x\) произойдет (то есть искомый элемент будет найден), а значит можно отбросить условие \(ind < n\). Такой вспомагательный элемент называют <i><b>«барьером»</b></i> или <i><b>«часовым»</b></i>, так как он препятствет выходу за пределы массива. В массиве теперь будет \(n+1\) элементов.
        </p>

<pre class="code"><code>a[n] = x;
int ind = 0;
while(a[ind] != x)
    ind++;</code></pre>
        <p>   
           Если, после завершения цикла, \(ind == n\), то искомого элемента в массиве нет.
        </p>
        <p>
        При реализации задач типа 2 (нахождение количества элементов) в любом случае придется просматривать весь массив.
        Если в задаче нужно найти количество элементов, то заведем переменную, значение которой будем увеличивать на 1 каждый раз, когда искомый элемент найден. Такую переменную называют<i><b> «счетчиком»</b></i>. 
        Перед поиском элементов  массива <i><b>«счетчику»</b></i> присваивается начальное значение (в данном случае равное нулю). 
        </p>

<pre class="code"><code>int cnt = 0;
for(int i = 0; i < n; i++){
   if(a[i]==x)
        cnt++;
}</code></pre> 
<hr>     
<h2>ПОИСК МАКСИМАЛЬНОГО И МИНИМАЛЬНОГО ЭЛЕМЕНТОВ В МАССИВЕ</h2>
<p>
    Рассмотрим задачу нахождения максимального элемента.
    В начале алгоритма примем элемент \(a[0]\) за максимальный и сохраним его в переменной \(mx\), а затем последовательно будем
    сравнивать это значение со значениями \(a[i]\).
    Если, в процессе сравнения, найдется элемент \(a[i]\), который большее,
    чем значение \(mx\), то присваиваем новое найденное значение \(a[i]\) переменной \(mx\), а затем продолжаем сравнения.

</p>
<pre class = "code"><code>int mx = a[0];
for(int i = 1; i < n; i++)
{
    if(a[i] > mx)
        mx = a[i];
}</code></pre>
<p>
    Можно переписать данный код используюя функциию \(max()\).
</p>
<pre class = "code"><code>int mx = a[0];
for(int i = 1; i < n; i++)
        mx = max(mx, a[i]);</code></pre>

<p>
  Часто бывает нужно найти не только максимальный элемент, 
  но и его положение в массиве (индекс).
  Для этого заведем еще одну переменную \(ind\).
</p>
<pre class = "code"><code>int mx = a[0];
int ind = 0;
for(int i = 1; i < n; i++)
{
    if(a[i] > mx)
    {
        mx = a[i];
        ind = i;
    }
}</code></pre>
<p>
ИЛИ (если нужен только индекс)
</p>
<pre class = "code"><code>int ind = 0;
for(int i = 1; i < n; i++)
    if(a[i] > a[ind])
        ind = i;</code></pre>
        <p>
          Заметим, что если в массиве есть несколько максимальных элементов, 
          то в переменной \(ind\) сохраняется первый найденный индекс.
          Если использовать условие \(a[i]>=a[ind]\), то будет сохранен 
          последний индекс максимального значения.<br>
          Если нужно найти минимальный элемент в массиве или его индекс,
          то нужно лишь в условии \(if\) поменять знак \(«>»\) на \(«<»\).<br>
          Понятно, что такой поиск максимального (минимального) элемента происходит 
          за \(O(n)\). 
        </p>

    </div>
</body>
</html>